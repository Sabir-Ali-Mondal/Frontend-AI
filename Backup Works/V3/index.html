<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sabir's Chatbot Interface</title>
    <link rel="icon" href="https://res.cloudinary.com/dmttn34te/image/upload/v1749298712/Generated_Image_June_07_2025_-_5_45PM_uin2s9.jpg" type="image/jpeg">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
</head>

<body>
    <!-- Toast Container for Notifications (Bootstrap) -->
    <div class="toast-container position-fixed p-3 top-0 end-0" id="toastPlacement">
        <!-- Toasts will be appended here by JS -->
    </div>

    <div class="container-fluid py-4">
        <!-- Tab Content: Placed first in DOM for flexbox ordering -->
        <div class="tab-content" id="mainTabContent">
            <!-- Chat Tab -->
            <div class="tab-pane fade show active" id="chatTabPane" role="tabpanel" aria-labelledby="chat-tab-btn">
                <div class="row justify-content-center">
                    <div class="col-lg-9 col-xl-8">
                        <div class="card">
                            <div class="card-body p-0">
                                <div class="chat-container" id="chatContainer">
                                    <div class="welcome-message" id="welcomeMessage">
                                        <div class="feature-icon">
                                            <i class="fas fa-brain"></i>
                                        </div>
                                        <h4>Hello! How can I help you today?</h4>
                                        <div class="row text-start justify-content-center mt-3">
                                            <div class="col-md-5">
                                                <ul class="list-unstyled">
                                                    <li><i class="fas fa-calculator text-primary me-2"></i>Perform calculations</li>
                                                    <li><i class="fas fa-question-circle text-primary me-2"></i>Answer questions</li>
                                                    <li><i class="fas fa-exchange-alt text-primary me-2"></i>Convert units</li>
                                                </ul>
                                            </div>
                                            <div class="col-md-5">
                                                <ul class="list-unstyled">
                                                    <li><i class="fas fa-flask text-primary me-2"></i>Recall scientific formulas</li>
                                                </ul>
                                            </div>
                                        </div>
                                        <p class="text-muted mt-3">Type your message below to get started.</p>
                                    </div>
                                    <!-- Messages will be appended here by JS -->
                                </div>
                            </div>
                            <div class="card-footer bg-light">
                                <form id="chatForm" class="d-flex gap-2">
                                    <input type="text" class="form-control form-control-lg" id="messageInput" placeholder="Ask me anything..." autocomplete="off">
                                    <div class="loading-spinner mt-2 align-self-center" id="loadingSpinner" style="display: none;">
                                        <!-- align-self-center -->
                                        <div class="d-flex align-items-center text-primary">
                                            <div class="loader me-2" role="status"></div>
                                        </div>
                                    </div>
                                    <button type="submit" class="btn btn-primary btn-lg" id="sendButton" title="Send Message">
                                        <i class="fas fa-paper-plane" style="color:blue;"></i>
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Training Tab -->
            <div class="tab-pane fade" id="trainingTabPane" role="tabpanel" aria-labelledby="training-tab-btn">
                <div class="row">
                    <div class="col-lg-6">
                        <!-- Prompt Generation Section -->
                        <div class="card mb-4">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="fas fa-lightbulb me-2"></i>Generate Training Prompts</h5>
                            </div>
                            <div class="card-body">
                                <div class="mb-3">
                                    <label for="topicInput" class="form-label">Enter Topic for Prompt:</label>
                                    <input type="text" class="form-control" id="topicInput" placeholder="e.g., Space Exploration, History of AI">
                                </div>
                                <div class="form-check form-switch mb-3">
                                    <input class="form-check-input" type="checkbox" role="switch" id="searchEngineToggle">
                                    <label class="form-check-label" for="searchEngineToggle">Use Perplexity.ai (else ChatGPT)</label>
                                </div>
                                <button class="btn btn-info w-100" id="generatePromptBtn">
                                    <i class="fas fa-rocket me-2"></i>Generate & Search Prompt
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-6">
                        <div class="card mb-4">
                            <div class="card-header">
                                <h5 class="mb-0">
                                    <i class="fas fa-file-code me-2"></i>Bulk Import Training Data (JSON from Text)
                                </h5>
                            </div>
                            <div class="card-body">
                                <p class="small text-muted">
                                    Paste JSON array below. Ensure it's an array of items or an object with "qa_pairs" and/or "calculation_patterns".
                                </p>
                                <textarea id="jsonImportTextArea" rows="8" class="form-control mb-2" placeholder="Paste JSON data here..."></textarea>
                                <button id="importJsonFromTextAreaBtn" class="btn btn-success w-100 mb-2">
                                    <i class="fas fa-upload me-2"></i>Import from Text Area
                                </button>
                                <button id="downloadJsonTemplateBtn" class="btn btn-secondary w-100">
                                    <i class="fas fa-download me-2"></i>Download JSON Template
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-6">
                        <div class="card">
                            <div class="card-body">
                                <pre class="bg-light mt-3 p-2 small rounded border mb-0"><code>Example JSON Structure:
{
  "qa_pairs": [
    {
      "question": "what is javascript",
      "answer": "JavaScript is a programming language."
    }
  ],
  "calculation_patterns": [
    {
      "pattern": "double of {number}",
      "action": "calculate_double",
      "formula": "result = 2 * number",
      "code_snippet": "function double(number) { return 2 * number; }"
    }
  ]
}
Or a simple array of Q&A:
[
  {"question": "q1", "answer": "a1"},
  {"question": "q2", "answer": "a2"}
]</code></pre>

                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Store/Data & Settings Tab -->
            <div class="tab-pane fade" id="storeTabPane" role="tabpanel" aria-labelledby="store-tab-btn">
                <div class="row">
                    <div class="col-lg-4">
                        <div class="stats-card mb-4">
                            <h5 class="mb-3"><i class="fas fa-chart-pie me-2"></i>Database Overview</h5>
                            <div class="row text-center">
                                <div class="col-4">
                                    <h3 id="totalQACount">0</h3><small>Q&A Pairs</small>
                                </div>
                                <div class="col-4">
                                    <h3 id="totalPatternCount">0</h3><small>Patterns</small>
                                </div>
                                <div class="col-4">
                                    <h3 id="totalMessageCount">0</h3><small>Messages</small>
                                </div>
                            </div>
                        </div>
                        <div class="card mb-4">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="fas fa-cogs me-2"></i>Quick Actions</h5>
                            </div>
                            <div class="card-body">
                                <div class="d-grid gap-2">
                                    <button class="btn btn-outline-info" id="installConversationData"> Install : <i class="fas fa-comments me-2"></i> Talk's and <span style="font-size:10px;">JKNOQUVWXYZ</span></button>
                                    <button class="btn btn-outline-info" id="installDictionaryData"> Install : <i class="fa-solid fa-calculator"></i> Formula's and API's</button>
                                    <div class="card mb-2" id="importProgressCard" style="display: none;">
                                        <div class="card-body p-2">
                                            <!-- Reduced padding -->
                                            <h6 class="mb-2 small"><i class="fas fa-spinner fa-spin me-2"></i>Importing Data...</h6>
                                            <div class="progress" style="height: 15px;">
                                                <!-- Reduced height -->
                                                <div class="progress-bar progress-bar-striped progress-bar-animated bg-success" id="progressBar" role="progressbar" style="width: 0%; font-size: 0.75em;">0%</div>
                                            </div>
                                            <small class="text-muted mt-1 d-block" id="progressText" style="font-size: 0.75em;">Preparing import...</small>
                                        </div>
                                    </div>
                                    <button class="btn btn-outline-success" id="exportAllData"><i class="fas fa-file-export me-2"></i>Export All Data (JSON)</button>
                                    <a href="https://drive.google.com/uc?export=download&id=10td4KBrArO45XstnPfFbRInGb_mXwSRy" class="btn btn-outline-secondary" download target="_blank">
                                        <i class="fas fa-cloud-download-alt me-2"></i> Download Full Dictionary (JSON)
                                    </a>
                                    <label for="importFile" class="btn btn-outline-warning mb-0 w-100"><i class="fas fa-file-import me-2"></i>Import Data (JSON File)</label>
                                    <input type="file" id="importFile" accept=".json" style="display: none;">
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header">
                                <h5 class="mb-0 text-danger"><i class="fas fa-exclamation-triangle me-2"></i>Danger Zone</h5>
                            </div>
                            <div class="card-body">
                                <div class="d-grid gap-2">
                                    <button class="btn btn-danger" id="clearChatHistory"><i class="fas fa-broom me-2"></i>Clear Chat History</button>
                                    <button class="btn btn-danger" id="resetEntireDatabase"><i class="fas fa-trash-alt me-2"></i>Reset Entire Database</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-lg-8">
                        <div class="card mb-3">
                            <div class="card-header">
                                <h5 class="mb-0"><i class="fas fa-info-circle me-2"></i>System Information</h5>
                            </div>
                            <div class="card-body">
                                <div class="row">
                                    <div class="col-md-6 mb-3">
                                        <h6><i class="fas fa-hdd me-2"></i>Storage Details</h6>
                                        <ul class="list-unstyled">
                                            <li><strong>Type:</strong> IndexedDB</li>
                                            <li><strong>DB Name:</strong> <code id="dbNameValue">AdvancedChatbotDB</code></li>
                                            <li><strong>Version:</strong> <code id="dbVersionValue">1</code></li>
                                            <li><strong>Status:</strong> <span class="badge bg-success" id="dbStatus">Connected</span></li>
                                        </ul>
                                        <h6><i class="fas fa-file-alt me-2"></i>Uploaded Files Log</h6>
                                        <div id="uploadedFilesInfo" style="font-size:0.9em; max-height: 100px; overflow-y:auto;" class="border rounded p-2 bg-light">
                                            <p class="text-muted small mb-0">No files imported yet.</p>
                                        </div>
                                        <button class="btn btn-sm btn-outline-danger mt-2" id="clearUploadedFilesRecords" title="Clear only the records of uploaded files, not the imported data itself.">
                                            <i class="fas fa-eraser me-1"></i> Clear Uploaded Files Log
                                        </button>
                                    </div>
                                    <div class="col-md-6 mb-3">
                                        <h6><i class="fas fa-check-circle me-2"></i>Supported Features</h6>
                                        <ul class="list-unstyled">
                                            <li><i class="fas fa-check text-success me-1"></i> Real-time Q '&' A</li>
                                            <li><i class="fas fa-check text-success me-1"></i> Dynamic Calculations</li>
                                            <li><i class="fas fa-check text-success me-1"></i> Trainable via Bulk JSON</li>
                                            <li><i class="fas fa-check text-success me-1"></i> Stemming & Fuzzy Matching</li>
                                        </ul>
                                        <h6><i class="fas fa-history me-2"></i>Recent Activity Log</h6>
                                        <div id="recentActivity" style="max-height: 150px; overflow-y: auto; font-size: 0.9em;" class="border rounded p-2 bg-light">
                                            <p class="text-muted small mb-0 p-2">No activity logged yet.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <h5 class="mb-0"><i class="fas fa-list-alt me-2"></i>Stored Training Data</h5>
                                <div class="search-box w-50">
                                    <input type="text" class="form-control form-control-sm" id="searchTraining" placeholder="Search training data (not implemented)...">
                                </div>
                            </div>
                            <div class="card-body" style="padding:20px;min-height: 400px; max-height: 60vh; overflow-y: auto;">
                                <ul class="nav nav-pills mb-3" id="trainingDataTabs" role="tablist">
                                    <li class="nav-item" role="presentation">
                                        <button class="nav-link active" id="qa-list-tab-btn" data-bs-toggle="pill" data-bs-target="#qaListPane" type="button" role="tab" aria-controls="qaListPane" aria-selected="true">
                                            Q&A (<span id="qaCount">0</span>)
                                        </button>
                                    </li>
                                    <li class="nav-item" role="presentation">
                                        <button class="nav-link" id="pattern-list-tab-btn" data-bs-toggle="pill" data-bs-target="#patternListPane" type="button" role="tab" aria-controls="patternListPane" aria-selected="false">
                                            Patterns & Calculations (<span id="patternCount">0</span>)
                                        </button>
                                    </li>
                                </ul>
                                <div class="tab-content" id="trainingDataTabContent">
                                    <div class="tab-pane fade show active" id="qaListPane" role="tabpanel" aria-labelledby="qa-list-tab-btn">
                                        <div id="qaList">
                                            <p class="text-muted text-center mt-3">No Q&A data trained yet. Add some using the 'Training' tab.</p>
                                        </div>
                                        <div class="pagination-container mt-3 d-flex justify-content-center" id="qaPagination"></div>
                                    </div>
                                    <div class="tab-pane fade" id="patternListPane" role="tabpanel" aria-labelledby="pattern-list-tab-btn">
                                        <div id="patternList">
                                            <p class="text-muted text-center mt-3">No patterns trained yet. Add some using the 'Training' tab.</p>
                                        </div>
                                        <div class="pagination-container mt-3 d-flex justify-content-center" id="patternPagination"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabs: Placed last in DOM for flexbox ordering -->
        <ul class="nav nav-tabs mb-0 d-flex" id="mainTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="chat-tab-btn" data-bs-toggle="tab" data-bs-target="#chatTabPane" type="button" role="tab" aria-controls="chatTabPane" aria-selected="true">
                    <i class="fas fa-comments me-2"></i>
                    Chat
                    <span class="badge bg-light text-primary ms-1" id="connectionStatus" title="Connection Status">Online</span>
                </button>
            </li>
            <div class="ms-auto d-flex">
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="training-tab-btn" data-bs-toggle="tab" data-bs-target="#trainingTabPane" type="button" role="tab" aria-controls="trainingTabPane" aria-selected="false" title="Training">
                        <i class="fas fa-graduation-cap"></i>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="store-tab-btn" data-bs-toggle="tab" data-bs-target="#storeTabPane" type="button" role="tab" aria-controls="storeTabPane" aria-selected="false" title="Data & Settings">
                        <i class="fas fa-gear"></i>
                    </button>
                </li>
            </div>
        </ul>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // --- CONSOLIDATED SCRIPT ---

        // --- Global State for Conversational Flow & Data (from snippet2) ---
        var pendingSuggestion = null;
        var pendingAnswer = null;

        // --- Constants & Configuration ---
        const DB_NAME = 'AdvancedSynergyChatDB'; // From snippet2
        const DB_VERSION = 1; // Consistent
        const STORES = { // Merged, ensuring all from snippet1 are present
            TRAINING_DATA: 'trainingData',
            CALCULATION_PATTERNS: 'calculationPatterns',
            DEFAULT_TRAINING: 'defaultTrainingData', // From snippet1
            UPLOADED_FILES: 'uploadedFilesLog', // snippet2's name
            CHAT_HISTORY: 'chatHistory'
        };

        const DEFAULT_CONVERSATION_URL = "https://raw.githubusercontent.com/Sabir-Ali-Mondal/Frontend-AI/main/new_data.json";
        const DEFAULT_DICTIONARY_URL = "https://raw.githubusercontent.com/Sabir-Ali-Mondal/Frontend-AI/main/dictionary.json";

        const SIMILARITY_THRESHOLDS = { // From snippet1
            HIGH: 50,
            MEDIUM: 30,
            LOW: 0 // Not directly used in snippet1's getResponse, but kept
        };

        const ITEMS_PER_PAGE_TRAINING = 10; // From snippet2

        // Using snippet2's more comprehensive stopwords list
        const stopwords = [
            "a", "about", "above", "after", "again", "against", "all", "am", "an", "and",
            "any", "are", "aren't", "as", "at", "be", "because", "been", "before", "being",
            "below", "between", "both", "but", "by", "can't", "cannot", "could", "couldn't",
            "did", "didn't", "do", "does", "doesn't", "doing", "don't", "down", "during",
            "each", "few", "for", "from", "further", "had", "hadn't", "has", "hasn't",
            "have", "haven't", "having", "he", "he'd", "he'll", "he's", "her", "here",
            "here's", "hers", "herself", "him", "himself", "his", "how", "how's", "i",
            "i'd", "i'll", "i'm", "i've", "if", "in", "into", "is", "isn't", "it", "it's",
            "its", "itself", "let's", "me", "more", "most", "mustn't", "my", "myself",
            "no", "nor", "not", "of", "off", "on", "once", "only", "or", "other", "ought",
            "our", "ours", "ourselves", "out", "over", "own", "same", "shan't", "she",
            "she'd", "she'll", "she's", "should", "shouldn't", "so", "some", "such",
            "than", "that", "that's", "the", "their", "theirs", "them", "themselves",
            "then", "there", "there's", "these", "they", "they'd", "they'll", "they're",
            "they've", "this", "those", "through", "to", "too", "under", "until", "up",
            "very", "was", "wasn't", "we", "we'd", "we'll", "we're", "we've", "were",
            "weren't", "what", "what's", "when", "when's", "where", "where's", "which",
            "while", "who", "who's", "whom", "why", "why's", "with", "won't", "would",
            "wouldn't", "you", "you'd", "you'll", "you're", "you've", "your", "yours",
            "yourself", "yourselves", "tell", "give", "ask", "explain", "define", "calculate", "compute", "find"
        ];

        // Using snippet2's confirmations (very similar to snippet1's)
        const positiveConfirmations = [
            "yes", "yess", "ya", "yaa", "ok", "okk", "okay", "okayy",
            "oky", "okyy", "hmm", "hmmm", "yep", "yepp", "yup", "yupp",
            "yah", "yahh", "aye", "ayee", "hm", "hmm", "sure", "suure",
            "alright", "alrighty", "right", "rightt", "yass", "yasss"
        ];
        const negativeConfirmations = [
            "no", "nah", "nope", "noo", "nuh-uh", "never", "not really",
            "no way", "no thanks", "nopeee", "naah", "nay", "uh-uh",
            "absolutely not", "not at all", "negative", "incorrect",
            "that's wrong", "not this time", "not quite", "definitely not"
        ];


        // --- UI Element Selectors (from snippet2) ---
        let chatContainer, messageInput, chatForm, loadingSpinner, welcomeMessageDiv,
            qaListDiv, patternListDiv, qaPaginationDiv, patternPaginationDiv,
            totalQACountEl, totalPatternCountEl, totalMessageCountEl,
            qaCountBadge, patternCountBadge, dbNameValueEl, dbVersionValueEl, dbStatusEl,
            recentActivityDiv, uploadedFilesInfoDiv, importProgressCard, progressBar,
            progressText, importFileEl, jsonImportTextArea, topicInput, searchEngineToggle;


        // --- Utility Functions (from snippet2, `notify` replaces `showNotification`) ---
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return String(unsafe);
            return unsafe.replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/"/g, "\"").replace(/'/g, "\'");
        }

        function showBootstrapToast(message, type = 'info', duration = 1000) { // From snippet2
            const toastPlacement = document.getElementById('toastPlacement');
            if (!toastPlacement) {
                console.error("Toast container #toastPlacement not found!");
                alert(message); // Fallback
                return;
            }
            const toastId = 'toast-' + Date.now();
            let bgClass = 'text-bg-' + type;
            let btnCloseClass = 'btn-close-white';
            if (type === 'warning' || type === 'light' || type === 'info') {
                bgClass = 'bg-' + type + ' text-dark';
                btnCloseClass = '';
            } else if (type === 'normal' || type === '') {
                bgClass = 'bg-secondary text-white';
            }

            const toastHTML = `
                <div id="${toastId}" class="toast align-items-center ${bgClass} border-0" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="${duration}">
                  <div class="d-flex">
                    <div class="toast-body">${escapeHtml(message)}</div>
                    <button type="button" class="btn-close me-2 m-auto ${btnCloseClass}" data-bs-dismiss="toast" aria-label="Close"></button>
                  </div>
                </div>`;
            toastPlacement.insertAdjacentHTML('beforeend', toastHTML);
            const toastEl = document.getElementById(toastId);
            if (bootstrap && bootstrap.Toast) { // Check if bootstrap is loaded
                const toast = new bootstrap.Toast(toastEl);
                toast.show();
                toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
            } else {
                console.warn("Bootstrap Toast component not found, using alert fallback for: " + message);
                alert(message); // Fallback if bootstrap not loaded
                setTimeout(() => toastEl.remove(), duration);
            }
        }
        const notify = showBootstrapToast; // Alias for consistency

        function addActivityLog(message) { // From snippet2
            if (!recentActivityDiv) return;
            const firstChildIsPlaceholder = recentActivityDiv.querySelector('p.text-muted.small.mb-0');
            if (firstChildIsPlaceholder) firstChildIsPlaceholder.remove();

            const logEntry = document.createElement('div');
            logEntry.classList.add('activity-item', 'small', 'border-bottom', 'pb-1', 'mb-1');
            const time = new Date().toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            logEntry.innerHTML = `<span class="text-muted">[${time}]</span> ${escapeHtml(message)}`;
            recentActivityDiv.insertBefore(logEntry, recentActivityDiv.firstChild);
            if (recentActivityDiv.children.length > 20) recentActivityDiv.removeChild(recentActivityDiv.lastChild);
        }

        // --- IndexedDB Functions (Enhanced with snippet1's onupgradeneeded) ---
        let dbInstance = null;

        function initDB() { // Merged approach
            return new Promise((resolve, reject) => {
                if (dbInstance) {
                    resolve(dbInstance);
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    // Training data store with question index (from snippet1)
                    if (!db.objectStoreNames.contains(STORES.TRAINING_DATA)) {
                        const trainingStore = db.createObjectStore(STORES.TRAINING_DATA, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        trainingStore.createIndex('question_idx', 'question', { // snippet2's name
                            unique: false
                        });
                        trainingStore.createIndex('timestamp_idx', 'timestamp', { // snippet2's addition
                            unique: false
                        });
                    }
                    // Calculation patterns store (from snippet1)
                    if (!db.objectStoreNames.contains(STORES.CALCULATION_PATTERNS)) {
                        const calcStore = db.createObjectStore(STORES.CALCULATION_PATTERNS, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        calcStore.createIndex('pattern_idx', 'pattern', { // snippet2's name
                            unique: false
                        });
                        calcStore.createIndex('timestamp_idx', 'timestamp', { // snippet2's addition
                            unique: false
                        });
                    }
                    // Default training data store (from snippet1)
                    if (!db.objectStoreNames.contains(STORES.DEFAULT_TRAINING)) {
                        db.createObjectStore(STORES.DEFAULT_TRAINING, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                    }
                    // Uploaded files metadata store (from snippet1, using snippet2's keyPath)
                    if (!db.objectStoreNames.contains(STORES.UPLOADED_FILES)) {
                        const filesStore = db.createObjectStore(STORES.UPLOADED_FILES, {
                            keyPath: 'filename' // from snippet2
                        });
                        filesStore.createIndex('timestamp_idx', 'timestamp', { // snippet2's name
                            unique: false
                        });
                    }
                    // Chat history store (from snippet1)
                    if (!db.objectStoreNames.contains(STORES.CHAT_HISTORY)) {
                        const chatStore = db.createObjectStore(STORES.CHAT_HISTORY, {
                            keyPath: 'id',
                            autoIncrement: true
                        });
                        chatStore.createIndex('timestamp_idx', 'timestamp', { // snippet2's name
                            unique: false
                        });
                    }
                };
                request.onsuccess = (event) => {
                    dbInstance = event.target.result;
                    dbInstance.onversionchange = function() {
                        dbInstance.close();
                        alert("Database is outdated, please reload the page.");
                        window.location.reload();
                    };
                    resolve(dbInstance);
                };
                request.onerror = (event) => {
                    console.error('IndexedDB initialization error:', event.target.error);
                    reject('IndexedDB initialization error: ' + event.target.error);
                };
            });
        }

        async function dbOperation(storeName, mode, operation, data) { // From snippet2
            const db = await initDB();
            return new Promise((resolve, reject) => {
                if (!db.objectStoreNames.contains(storeName)) {
                    return reject(new Error(`Store ${storeName} does not exist.`));
                }
                const transaction = db.transaction(storeName, mode);
                const store = transaction.objectStore(storeName);
                let request;
                switch (operation) {
                    case 'add':
                        request = store.add(data);
                        break;
                    case 'put':
                        request = store.put(data);
                        break;
                    case 'get':
                        request = store.get(data);
                        break;
                    case 'getAll':
                        request = store.getAll();
                        break;
                    case 'delete':
                        request = store.delete(data);
                        break;
                    case 'clear':
                        request = store.clear();
                        break;
                    default:
                        return reject(new Error('Invalid DB operation.'));
                }
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        // Using snippet2's CRUD wrappers
        const addRecord = (s, d) => dbOperation(s, 'readwrite', 'add', d);
        const updateRecord = (s, d) => dbOperation(s, 'readwrite', 'put', d);
        const getRecordById = (s, id) => dbOperation(s, 'readonly', 'get', id);
        const getAllRecords = (s) => dbOperation(s, 'readonly', 'getAll');
        const deleteRecord = (s, id) => dbOperation(s, 'readwrite', 'delete', id);
        const clearStore = (s) => dbOperation(s, 'readwrite', 'clear');

        // Training data specific operations (from snippet1, using general addRecord)
        async function addTrainingData(question, answer) { // From snippet1
            return addRecord(STORES.TRAINING_DATA, {
                question: question.toLowerCase().trim(),
                answer: answer.trim(),
                timestamp: Date.now()
            });
        }
        // Use snippet2's addCalcPatternData for consistency with code_snippet
        const addCalcPatternData = (p, act, f, cs = '') => addRecord(STORES.CALCULATION_PATTERNS, {
            pattern: p.toLowerCase().trim(),
            action: act.trim(),
            formula: f.trim(),
            code_snippet: cs.trim(),
            timestamp: Date.now()
        });
        // addCalculationPattern from snippet1 is now covered by addCalcPatternData

        // --- Migration from localStorage (from snippet1) ---
        async function migrateFromLocalStorage() {
            try {
                const trainingDataLS = localStorage.getItem('trainingData');
                const defaultTrainingDataLS = localStorage.getItem('defaultTrainingData');
                const uploadedFilesLS = localStorage.getItem('uploadedFiles');

                if (!trainingDataLS && !defaultTrainingDataLS && !uploadedFilesLS) {
                    return false; // No migration needed
                }
                notify('Migration from localStorage to IndexedDB in progress...', 'info');

                if (trainingDataLS) {
                    const parsedData = JSON.parse(trainingDataLS);
                    for (const question in parsedData) {
                        if (parsedData.hasOwnProperty(question)) {
                            await addTrainingData(question, parsedData[question]);
                        }
                    }
                }
                if (defaultTrainingDataLS) {
                    const parsedData = JSON.parse(defaultTrainingDataLS);
                    // Assuming parsedData is the actual data, not an object with a 'data' property
                    await addRecord(STORES.DEFAULT_TRAINING, {
                        id: 'migrated_default_qa', // Give it a specific ID
                        data: parsedData, // Store the whole array/object
                        timestamp: Date.now()
                    });
                }
                if (uploadedFilesLS) {
                    const parsedFiles = JSON.parse(uploadedFilesLS);
                    for (const file of parsedFiles) {
                        await addRecord(STORES.UPLOADED_FILES, { // Using snippet2's store name
                            filename: file.name || `migrated_unknown_${Date.now()}`,
                            timestamp: file.timestamp || Date.now(),
                            size: file.size || 0,
                            type: file.type || 'application/json'
                        });
                    }
                }
                localStorage.removeItem('trainingData');
                localStorage.removeItem('defaultTrainingData');
                localStorage.removeItem('uploadedFiles');
                // localStorage.clear(); // Be cautious with full clear if other LS items exist
                notify('Migration complete. Data has been transferred to IndexedDB.', 'success');
                return true;
            } catch (error) {
                console.error('Migration error:', error);
                notify('Error during migration: ' + error.message, 'error');
                return false;
            }
        }

        // --- Core Chatbot Logic (from snippet1, text processing and similarity) ---
        function cleanInput(text, forMatching = true) {
            const cleaned = text.toLowerCase();
            if (forMatching) {
                const words = cleaned.replace(/[?,.;]/g, '').split(/\s+/);
                if (words.length === 1) return words[0]; // Keep the single word, even if it's a stopword
                return words
                    .filter(word => !stopwords.includes(word))
                    .join(' ');
            }
            return cleaned;
        }


        function levenshteinDistance(str1, str2) { // From snippet1
            const s1 = str1 || ""; // Handle null/undefined
            const s2 = str2 || "";
            const matrix = [];
            for (let i = 0; i <= s1.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= s2.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= s1.length; i++) {
                for (let j = 1; j <= s2.length; j++) {
                    const cost = s1.charAt(i - 1) === s2.charAt(j - 1) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1, // deletion
                        matrix[i][j - 1] + 1, // insertion
                        matrix[i - 1][j - 1] + cost // substitution
                    );
                }
            }
            return matrix[s1.length][s2.length];
        }

        function calculateSimilarity(str1, str2) { // From snippet1
            if (!str1 || !str2) return 0;
            const cleaned1 = cleanInput(str1, true);
            const cleaned2 = cleanInput(str2, true);

            if (!cleaned1 && !cleaned2) return 1; // Both empty after cleaning
            if (!cleaned1 || !cleaned2) return 0; // One empty after cleaning

            if (cleaned1 === cleaned2) return 1;

            const words1 = cleaned1.split(/\s+/);
            const words2 = cleaned2.split(/\s+/);
            let matchingWords = 0;
            const setWords2 = new Set(words2);
            words1.forEach(word => {
                if (setWords2.has(word)) matchingWords++;
            });

            const wordSimilarity = (words1.length + words2.length > 0) ? (2.0 * matchingWords) / (words1.length + words2.length) : 0;

            const levenshtein = levenshteinDistance(cleaned1, cleaned2);
            const maxLength = Math.max(cleaned1.length, cleaned2.length);
            const charSimilarity = maxLength > 0 ? (1 - (levenshtein / maxLength)) : 0;

            return (wordSimilarity * 0.6) + (charSimilarity * 0.4);
        }

        async function findBestMatch(input) { // From snippet1
            const trainingData = await getAllRecords(STORES.TRAINING_DATA);
            if (!trainingData || trainingData.length === 0) return null;

            let bestMatch = null;
            let bestScore = -1; // Initialize to allow 0 score matches

            for (const item of trainingData) {
                // Ensure item.question and item.answer are strings
                const itemQuestion = String(item.question || "");
                const itemAnswer = String(item.answer || "");
                const inputString = String(input || "");

                const questionSimilarity = calculateSimilarity(inputString, itemQuestion);
                const answerSimilarity = calculateSimilarity(inputString, itemAnswer); // Consider if matching answer is desired
                const maxSimilarity = Math.max(questionSimilarity, answerSimilarity);

                if (maxSimilarity > bestScore) {
                    bestScore = maxSimilarity;
                    bestMatch = {
                        item,
                        similarity: bestScore,
                        matchedAnswer: questionSimilarity < answerSimilarity && answerSimilarity > 0.1 // Be somewhat confident it matched answer
                    };
                }
            }
            return bestMatch;
        }

        async function processWordByWord(input) { // From snippet1
            const words = cleanInput(input, false).split(/\s+/); // forMatching=false to keep original word forms
            const results = [];
            const processedWords = new Set();

            const exactMatchWholeInput = await findBestMatch(input); // Check whole input first
            if (exactMatchWholeInput && exactMatchWholeInput.similarity * 100 >= SIMILARITY_THRESHOLDS.HIGH) {
                return exactMatchWholeInput.item.answer; // If strong match for whole, prefer it.
            }

            for (const word of words) {
                if (!stopwords.includes(word.toLowerCase()) && !processedWords.has(word) && word.length > 1) { // Avoid stopwords and short words
                    const match = await findBestMatch(word); // Match individual word
                    if (match && match.similarity * 100 >= SIMILARITY_THRESHOLDS.MEDIUM) {
                        results.push({
                            text: word,
                            answer: match.item.answer,
                            similarity: match.similarity
                        });
                        processedWords.add(word);
                    }
                }
            }
            if (results.length > 0) {
                return results
                    .sort((a, b) => b.similarity - a.similarity)
                    .map(result => `Regarding "${result.text}": ${result.answer}`)
                    .join('\n---\n'); // Use a more distinct separator
            }
            return null;
        }

        // --- Calculation Logic (from snippet1, to be called by getResponse) ---
        function factorial(n) { // From snippet1
            if (n === 0 || n === 1) return 1;
            if (n < 0) return "Factorial is only defined for non-negative integers";
            if (n > 20) return "Number too large for factorial (max 20)"; // Prevent overflow/performance issues
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        function isArithmetic(input) { // From snippet1
            const arithmeticRegex = /\d+(\s*[\+\-\*\/\^\%]\s*\d+)+/;
            return arithmeticRegex.test(input);
        }

        function extractArithmetic(input) { // From snippet1
            const matches = input.match(/\d+(\s*[\+\-\*\/\^\%]\s*\d+)+/g);
            return matches ? matches[0] : null;
        }

        function evaluateArithmetic(expression) { // From snippet1
            if (!expression) return null;
            expression = expression.replace(/\^/g, '**').replace(/\%/g, '/100*'); // Basic % handling
            try {
                // Sanitize further: only allow numbers, operators, parentheses, decimal points
                const sanitizedExpression = expression.replace(/[^0-9+\-*/.() ]/g, '');
                if (sanitizedExpression.length === 0) return "Invalid calculation";
                // Avoid direct new Function if possible, but for this limited scope it's common
                const result = new Function(`return ${sanitizedExpression}`)();
                if (isNaN(result) || !isFinite(result)) {
                    return "Invalid calculation result (NaN or Infinity)";
                }
                return result;
            } catch (error) {
                console.error("Error evaluating arithmetic:", error);
                return null; // "Error in calculation"
            }
        }

        async function checkFunctionPatterns(input) { // From snippet1
            // Assumes math.js is loaded if you want to use math.evaluate
            // Add <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js">
            try {
                if (typeof math !== 'undefined') {
                    try {
                        let mathInput = input
                            .replace(/what is/gi, '')
                            .replace(/calculate/gi, '')
                            .replace(/times/gi, '*')
                            .replace(/multiplied by/gi, '*')
                            .replace(/divided by/gi, '/')
                            .replace(/plus/gi, '+')
                            .replace(/minus/gi, '-')
                            .replace(/squared/gi, '^2')
                            .replace(/cubed/gi, '^3')
                            .trim();
                        if (isArithmetic(mathInput)) { // Only evaluate if it looks like an expression
                            const result = math.evaluate(mathInput);
                            if (result !== undefined && typeof result !== 'function' && !isNaN(parseFloat(result))) {
                                return result;
                            }
                        }
                    } catch (e) {
                        // console.log("Not a direct math.js expression, continuing to patterns");
                    }
                }

                const patterns = await getAllRecords(STORES.CALCULATION_PATTERNS);
                const lowerInput = input.toLowerCase();

                for (const pattern of patterns) {
                    const lowerPatternPattern = (pattern.pattern || "").toLowerCase();
                    if (lowerPatternPattern && lowerInput.includes(lowerPatternPattern)) {
                        const numbers = input.match(/\d+(\.\d+)?/g);
                        if (numbers && numbers.length > 0) {
                            const firstNum = parseFloat(numbers[0]);
                            switch (pattern.action) { // These are snippet1's specific actions
                                case 'calculate_double':
                                    return 2 * firstNum;
                                case 'calculate_square':
                                    return Math.pow(firstNum, 2);
                                case 'calculate_percentage':
                                    if (numbers.length >= 2) {
                                        const percentage = firstNum;
                                        const total = parseFloat(numbers[1]);
                                        return (percentage / 100) * total;
                                    }
                                    break;
                                case 'calculate_factorial':
                                    const n = parseInt(numbers[0]);
                                    if (!isNaN(n)) return factorial(n);
                                    break;
                                    // Add more cases here if snippet1 had more specific actions
                            }
                        }
                    }
                }
                // Fallback basic arithmetic if no specific pattern matched
                if (isArithmetic(input)) {
                    const mathExpression = extractArithmetic(input);
                    if (mathExpression) {
                        try {
                            if (typeof math !== 'undefined') return math.evaluate(mathExpression);
                            return evaluateArithmetic(mathExpression); // Use basic evaluator
                        } catch (error) {
                            /* console.error("Arithmetic fallback error:", error); */
                        }
                    }
                }
                return null;
            } catch (error) {
                console.error("Error in checkFunctionPatterns:", error);
                return null;
            }
        }


        // --- Core Text-Based Response Generation Logic (from snippet1, adapted) ---
        async function getResponse(rawInput) { // From snippet1, now the main getResponse
            const sanitizedInput = rawInput.trim().toLowerCase();
            let response = '';

            // Handle pending suggestions (from snippet2 logic, integrated here)
            if (pendingSuggestion) {
                if (positiveConfirmations.includes(sanitizedInput)) {
                    const ans = pendingAnswer;
                    pendingSuggestion = null;
                    pendingAnswer = null;
                    return ans;
                } else if (negativeConfirmations.includes(sanitizedInput)) {
                    pendingSuggestion = null;
                    pendingAnswer = null;
                    return "Okay, what else can I help you with?";
                }
                // If not a confirmation, let the normal flow continue below,
                // but clear pending suggestion as it's a new query.
                pendingSuggestion = null;
                pendingAnswer = null;
            }


            // Check for calculations (from snippet1's getResponse logic)
            const calculationResult = await checkFunctionPatterns(sanitizedInput); // Uses snippet1's patterns

            const bestMatch = await findBestMatch(sanitizedInput); // Uses snippet1's matching

            if (calculationResult !== null) {
                if (bestMatch && bestMatch.similarity * 100 >= SIMILARITY_THRESHOLDS.MEDIUM) { // If also a medium QA match
                    response = `${bestMatch.item.answer}\n\nRegarding a possible calculation: ${calculationResult}`;
                } else {
                    response = `The result is: ${calculationResult}`;
                }
            } else if (bestMatch) {
                if (bestMatch.similarity * 100 >= SIMILARITY_THRESHOLDS.HIGH) {
                    response = bestMatch.matchedAnswer ?
                        `Your input sounds like an answer. Were you perhaps looking for information related to: "${bestMatch.item.question}"? (yes/no)` :
                        bestMatch.item.answer;
                    if (bestMatch.matchedAnswer) {
                        pendingSuggestion = bestMatch.item.question;
                        pendingAnswer = bestMatch.item.answer;
                    }
                } else if (bestMatch.similarity * 100 >= SIMILARITY_THRESHOLDS.MEDIUM) {
                    response = `Did you mean: "${bestMatch.item.question}"? (yes/no)`;
                    pendingSuggestion = bestMatch.item.question;
                    pendingAnswer = bestMatch.item.answer;
                } else {
                    // Try word by word analysis if complete match isn't strong enough
                    const wordByWordResponse = await processWordByWord(rawInput); // Use rawInput for wbw
                    if (wordByWordResponse) {
                        response = wordByWordResponse;
                    } else {
                        response = "I'm not quite sure. Could you rephrase that or ask something else?";
                    }
                }
            } else {
                // Try word by word as a last resort if no match at all
                const wordByWordResponse = await processWordByWord(rawInput); // Use rawInput
                response = wordByWordResponse || "I don't understand. Could you try asking differently?";
            }
            return response;
        }

        // --- Porter Stemmer (Simplified Implementation from snippet2) ---
        const PorterStemmer = (function() {
            /* ... snippet2's PorterStemmer code ... */
            const step2list = {
                    "ational": "ate",
                    "tional": "tion",
                    "enci": "ence",
                    "anci": "ance",
                    "izer": "ize",
                    "bli": "ble",
                    "alli": "al",
                    "entli": "ent",
                    "eli": "e",
                    "ousli": "ous",
                    "ization": "ize",
                    "ation": "ate",
                    "ator": "ate",
                    "alism": "al",
                    "iveness": "ive",
                    "fulness": "ful",
                    "ousness": "ous",
                    "aliti": "al",
                    "iviti": "ive",
                    "biliti": "ble",
                    "logi": "log"
                },
                step3list = {
                    "icate": "ic",
                    "ative": "",
                    "alize": "al",
                    "iciti": "ic",
                    "ical": "ic",
                    "ful": "",
                    "ness": ""
                },
                c = "[^aeiou]",
                v = "[aeiouy]",
                C = c + "[^aeiouy]*",
                V = v + "[aeiou]*",
                mgr0 = "^(" + C + ")?" + V + C,
                meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",
                mgr1 = "^(" + C + ")?" + V + C + V + C,
                s_v = "^(" + C + ")?" + v;

            function stemWord(w) {
                let stem, suffix, firstch, origword = w;
                if (w.length < 3) return w;
                firstch = w.substring(0, 1);
                if (firstch == "y") w = firstch.toUpperCase() + w.substring(1);
                let re = /^(.+?)(ss|i)es$/;
                let re2 = /^(.+?)([^s])s$/;
                if (re.test(w)) {
                    w = w.replace(re, "$1$2")
                } else if (re2.test(w)) {
                    w = w.replace(re2, "$1$2")
                }
                re = /^(.+?)eed$/;
                re2 = /^(.+?)(ed|ing)$/;
                if (re.test(w)) {
                    let fp = re.exec(w);
                    re = new RegExp(mgr0);
                    if (re.test(fp[1])) {
                        let temp = fp[1];
                        w = temp.substring(0, temp.length - 1)
                    }
                } else if (re2.test(w)) {
                    let fp = re2.exec(w);
                    stem = fp[1];
                    re2 = new RegExp(s_v);
                    if (re2.test(stem)) {
                        w = stem;
                        re2 = /(at|bl|iz)$/;
                        re = new RegExp("([^aeiouylsz])\\1$");
                        let re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
                        if (re2.test(w)) {
                            w = w + "e"
                        } else if (re.test(w)) {
                            let temp = w;
                            w = temp.substring(0, temp.length - 1)
                        } else if (re3.test(w)) {
                            w = w + "e"
                        }
                    }
                }
                re = /^(.+?)y$/;
                if (re.test(w)) {
                    let fp = re.exec(w);
                    stem = fp[1];
                    re = new RegExp(s_v);
                    if (re.test(stem)) {
                        w = stem + "i"
                    }
                }
                re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
                if (re.test(w)) {
                    let fp = re.exec(w);
                    stem = fp[1];
                    suffix = fp[2];
                    re = new RegExp(mgr0);
                    if (re.test(stem)) {
                        w = stem + step2list[suffix]
                    }
                }
                re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
                if (re.test(w)) {
                    let fp = re.exec(w);
                    stem = fp[1];
                    suffix = fp[2];
                    re = new RegExp(mgr0);
                    if (re.test(stem)) {
                        w = stem + step3list[suffix]
                    }
                }
                re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
                re2 = /^(.+?)(s|t)(ion)$/;
                if (re.test(w)) {
                    let fp = re.exec(w);
                    stem = fp[1];
                    re = new RegExp(mgr1);
                    if (re.test(stem)) {
                        w = stem
                    }
                } else if (re2.test(w)) {
                    let fp = re2.exec(w);
                    stem = fp[1] + fp[2];
                    re2 = new RegExp(mgr1);
                    if (re2.test(stem)) {
                        w = stem
                    }
                }
                re = /^(.+?)e$/;
                if (re.test(w)) {
                    let fp = re.exec(w);
                    stem = fp[1];
                    re = new RegExp(mgr1);
                    re2 = new RegExp(meq1);
                    let re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
                    if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
                        w = stem
                    }
                }
                re = /ll$/;
                re2 = new RegExp(mgr1);
                if (re.test(w) && re2.test(w)) {
                    let temp = w;
                    w = temp.substring(0, temp.length - 1)
                }
                if (firstch == "y" && w.length > 0) {
                    w = firstch.toLowerCase() + w.substring(1)
                }
                return w
            }
            return {
                stem: stemWord
            }
        })();


        // --- Calculation Execution Logic (from snippet2 - for code_snippet patterns) ---
        async function executeDynamicCalculation(pattern, input) { // From snippet2
            try {
                const numbers = input.match(/\d+(?:\.\d+)?/g);
                if (!pattern.code_snippet || typeof pattern.code_snippet !== 'string' || pattern.code_snippet.trim() === '') {
                    return null; // No snippet, so this function doesn't apply
                }
                if (!numbers || numbers.length === 0 && !pattern.code_snippet.includes("()")) { // Allow no-arg functions
                    // Return specific message only if numbers are expected but not found
                    if (pattern.code_snippet.match(/num\d*|\.\.\.nums/)) { // Heuristic: if snippet expects numbers
                        return `Please provide numbers for the calculation: "${pattern.pattern}".`;
                    }
                }
                const nums = numbers ? numbers.map(n => parseFloat(n)) : [];

                try {
                    const dynamicFunction = new Function('return ' + pattern.code_snippet)();
                    const result = dynamicFunction(...nums);
                    return result;
                } catch (e) {
                    console.error(`Error executing code snippet for pattern "${pattern.pattern}":`, e, "\nSnippet:", pattern.code_snippet, "\nInput Nums:", nums);
                    return `Calculation error in custom code for "${pattern.pattern}": ${e.message}`;
                }
            } catch (error) {
                console.error(`Error processing calculation for pattern "${pattern.pattern}":`, error);
                return `Error processing calculation: ${error.message}`;
            }
        }

        // --- Chat Message UI (from snippet2 - more advanced) ---
        function appendChatMessage(sender, messageContent, timestamp = Date.now(), isTyping = false) {
            /* ... snippet2's appendChatMessage ... */
            if (welcomeMessageDiv && !welcomeMessageDiv.classList.contains('hidden')) {
                welcomeMessageDiv.classList.add('hidden');
            }
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender === 'user' ? 'user-message' : 'bot-message');

            if (isTyping) {
                messageDiv.classList.add('is-typing');
                messageDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
            } else {
                let finalHtmlContent = "";
                if (sender === 'bot') {
                    let htmlContent = escapeHtml(String(messageContent)); // Ensure string
                    htmlContent = htmlContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                    htmlContent = htmlContent.replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="code-block"><code>${p1.trim()}</code></pre>`);
                    htmlContent = htmlContent.replace(/`([^`]+)`/g, '<code>$1</code>');
                    finalHtmlContent = htmlContent.replace(/\n/g, '<br>');
                } else {
                    finalHtmlContent = escapeHtml(String(messageContent));
                }
                messageDiv.innerHTML = finalHtmlContent;

                const timeSpan = document.createElement('span');
                timeSpan.classList.add('message-time');
                timeSpan.textContent = new Date(timestamp).toLocaleTimeString([], {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                messageDiv.appendChild(timeSpan);
            }
            if (chatContainer) {
                chatContainer.appendChild(messageDiv);
                chatContainer.scrollTop = chatContainer.scrollHeight;
            } else {
                console.error("chatContainer is null in appendChatMessage");
            }
        }

        async function typeBotMessage(messageContent) {
            /* ... snippet2's typeBotMessage ... */
            if (!chatContainer) {
                console.error("chatContainer is null in typeBotMessage");
                appendChatMessage('bot', messageContent); // Fallback to non-typed
                return;
            }
            const typingEl = chatContainer.querySelector('.is-typing');
            if (typingEl) typingEl.remove();

            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', 'bot-message');
            chatContainer.appendChild(messageDiv);

            const rawMessageContent = String(messageContent); // Ensure string
            let typedTextAccumulator = "";

            for (let i = 0; i < rawMessageContent.length; i++) {
                typedTextAccumulator += rawMessageContent[i];
                let tempTypedHtml = escapeHtml(typedTextAccumulator);
                tempTypedHtml = tempTypedHtml.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // Bold
                tempTypedHtml = tempTypedHtml.replace(/`([^`]+)`/g, '<code>$1</code>'); // Inline code
                // Avoid processing ``` during typing for simplicity, apply at the end.
                tempTypedHtml = tempTypedHtml.replace(/\n/g, '<br>'); // Newlines
                messageDiv.innerHTML = tempTypedHtml;
                chatContainer.scrollTop = chatContainer.scrollHeight;
                await delay(rawMessageContent[i] === '.' || rawMessageContent[i] === '?' || rawMessageContent[i] === '!' ? 150 : 10); // Pause for punctuation
            }
            // Final render with full markdown processing for ```
            let finalHtmlContent = escapeHtml(rawMessageContent);
            finalHtmlContent = finalHtmlContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            finalHtmlContent = finalHtmlContent.replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="code-block"><code>${p1.trim()}</code></pre>`);
            finalHtmlContent = finalHtmlContent.replace(/`([^`]+)`/g, '<code>$1</code>');
            finalHtmlContent = finalHtmlContent.replace(/\n/g, '<br>');
            messageDiv.innerHTML = finalHtmlContent;

            const timeSpan = document.createElement('span');
            timeSpan.classList.add('message-time');
            timeSpan.textContent = new Date().toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit'
            });
            messageDiv.appendChild(timeSpan);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }


        // --- Import/Export & File Handling (using snippet1's core, snippet2's UI wrappers) ---
        async function importJSON(jsonData) { // From snippet1, adapted for snippet2's progress UI
            let count = 0,
                importedItems = 0,
                totalItemsToImport = 0;
            if (Array.isArray(jsonData)) totalItemsToImport = jsonData.length;
            else {
                if (jsonData.qa_pairs) totalItemsToImport += jsonData.qa_pairs.length;
                if (jsonData.calculation_patterns) totalItemsToImport += jsonData.calculation_patterns.length;
            }
            if (progressText) progressText.textContent = `Preparing to import ${totalItemsToImport} items...`;

            function updateProgressUI() {
                importedItems++;
                const percentage = totalItemsToImport > 0 ? Math.round((importedItems / totalItemsToImport) * 100) : 0;
                if (progressBar) {
                    progressBar.style.width = percentage + '%';
                    progressBar.textContent = percentage + '%';
                }
                if (progressText) progressText.textContent = `Importing ${importedItems} of ${totalItemsToImport}...`;
            }

            try {
                if (Array.isArray(jsonData)) { // Handles old format of direct QA array
                    for (const pair of jsonData) {
                        if (pair.question && pair.answer) {
                            await addTrainingData(pair.question, pair.answer); // Uses snippet1's add
                            count++;
                            updateProgressUI();
                        }
                    }
                } else { // Handles new format with qa_pairs and calculation_patterns
                    if (jsonData.qa_pairs && Array.isArray(jsonData.qa_pairs)) {
                        for (const pair of jsonData.qa_pairs) {
                            if (pair.question && pair.answer) {
                                await addTrainingData(pair.question, pair.answer); // Uses snippet1's add
                                count++;
                                updateProgressUI();
                            }
                        }
                    }
                    if (jsonData.calculation_patterns && Array.isArray(jsonData.calculation_patterns)) {
                        for (const p of jsonData.calculation_patterns) {
                            if (p.pattern && p.action) { // formula is optional for snippet1 type patterns
                                await addCalcPatternData(p.pattern, p.action, p.formula || '', p.code_snippet || ''); // Uses snippet2's add
                                count++;
                                updateProgressUI();
                            }
                        }
                    }
                }
                return count;
            } catch (error) {
                console.error('Error importing JSON data:', error);
                throw error; // Re-throw for the caller to handle
            }
        }
        const importJSONFromFile = importJSON; // Alias for snippet2's handler

        async function exportToJSON() { // From snippet1
            try {
                const trainingData = await getAllRecords(STORES.TRAINING_DATA);
                const calculationPatterns = await getAllRecords(STORES.CALCULATION_PATTERNS);

                const exportData = {
                    export_timestamp: new Date().toISOString(), // Added by snippet2's style
                    qa_pairs: trainingData.map(item => ({
                        id: item.id,
                        question: item.question,
                        answer: item.answer,
                        timestamp: item.timestamp
                    })),
                    calculation_patterns: calculationPatterns.map(item => ({
                        id: item.id,
                        pattern: item.pattern,
                        action: item.action,
                        formula: item.formula,
                        code_snippet: item.code_snippet,
                        timestamp: item.timestamp
                    }))
                };
                return JSON.stringify(exportData, null, 2);
            } catch (error) {
                console.error('Error exporting JSON:', error);
                throw error;
            }
        }

        // --- UI Update Functions (from snippet2, largely unchanged) ---
        async function renderTrainingList(listType, page = 1) {
            /* ... snippet2's renderTrainingList ... */
            const listEl = listType === 'qa' ? qaListDiv : patternListDiv;
            const pagEl = listType === 'qa' ? qaPaginationDiv : patternPaginationDiv;
            const store = listType === 'qa' ? STORES.TRAINING_DATA : STORES.CALCULATION_PATTERNS;

            if (!listEl || !pagEl) {
                console.error(`UI elements for ${listType} list not found.`);
                return;
            }
            listEl.innerHTML = `<div class="text-center p-3"><div class="spinner-border spinner-border-sm" role="status"></div> Loading...</div>`;
            pagEl.innerHTML = '';

            try {
                const allItems = (await getAllRecords(store)).sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                const totalItems = allItems.length;
                const totalPages = Math.ceil(totalItems / ITEMS_PER_PAGE_TRAINING) || 1;
                page = Math.max(1, Math.min(page, totalPages));
                const paginatedItems = allItems.slice((page - 1) * ITEMS_PER_PAGE_TRAINING, page * ITEMS_PER_PAGE_TRAINING);

                listEl.innerHTML = '';
                if (paginatedItems.length === 0) {
                    listEl.innerHTML = `<p class="text-muted text-center mt-3">No ${listType === 'qa' ? 'Q&A entries' : 'patterns'} found. Use the 'Training' tab to add or import data.</p>`;
                } else {
                    paginatedItems.forEach(item => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = `training-item p-2 border-bottom`;
                        let contentHTML = '';
                        if (listType === 'qa') {
                            contentHTML = `<div class="fw-bold">${escapeHtml(item.question)}</div><div>${escapeHtml(item.answer)}</div>`;
                        } else { // Calculation Pattern
                            contentHTML = `<div><strong>Pattern:</strong> <code>${escapeHtml(item.pattern)}</code></div>
                                       <div><strong>Action:</strong> ${escapeHtml(item.action)}</div>
                                       <small class="text-muted">Formula: ${escapeHtml(item.formula || 'N/A')}</small><br>
                                       ${item.code_snippet ? `<small class="text-muted">Code Snippet:</small><pre class="code-snippet bg-light p-1 m-0 mt-1 rounded" style="font-size:0.8em; max-height: 100px; overflow-y:auto;">${escapeHtml(item.code_snippet)}</pre>` : ''}`;
                        }
                        itemDiv.innerHTML = `${contentHTML}
                        <div class="actions mt-1 text-end">
                            <button class="btn btn-sm btn-outline-primary edit-btn" data-id="${item.id}" data-type="${listType}" title="Edit"><i class="fas fa-edit"></i></button>
                            <button class="btn btn-sm btn-outline-danger delete-btn" data-id="${item.id}" data-type="${listType}" title="Delete"><i class="fas fa-trash"></i></button>
                        </div>`;
                        listEl.appendChild(itemDiv);
                    });
                }
                if (totalPages > 1) createPaginationControls(pagEl, listType, page, totalPages);
                await updateCountsUI();
            } catch (error) {
                console.error(`Error rendering ${listType} list:`, error);
                listEl.innerHTML = `<p class="text-center text-danger">Error loading data. ${error.message}</p>`;
            }
        }

        function createPaginationControls(pagEl, listType, currentPage, totalPages) {
            /* ... snippet2's createPaginationControls ... */
            pagEl.innerHTML = '';
            const maxPagesToShow = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxPagesToShow / 2));
            let endPage = Math.min(totalPages, startPage + maxPagesToShow - 1);
            if (endPage - startPage + 1 < maxPagesToShow && startPage > 1) startPage = Math.max(1, endPage - maxPagesToShow + 1);

            if (currentPage > 1) pagEl.appendChild(createPageButton(listType, 1, '<i class="fas fa-angle-double-left"></i>'));
            if (currentPage > 1) pagEl.appendChild(createPageButton(listType, currentPage - 1, '<i class="fas fa-angle-left"></i>'));
            for (let i = startPage; i <= endPage; i++) pagEl.appendChild(createPageButton(listType, i, i, currentPage === i));
            if (currentPage < totalPages) pagEl.appendChild(createPageButton(listType, currentPage + 1, '<i class="fas fa-angle-right"></i>'));
            if (currentPage < totalPages) pagEl.appendChild(createPageButton(listType, totalPages, '<i class="fas fa-angle-double-right"></i>'));
        }

        function createPageButton(listType, pageNum, text, isActive = false) {
            /* ... snippet2's createPageButton ... */
            const btn = document.createElement('button');
            btn.className = `btn btn-sm mx-1 ${isActive ? 'btn-primary active' : 'btn-outline-primary'}`;
            btn.innerHTML = text;
            btn.onclick = () => renderTrainingList(listType, pageNum);
            return btn;
        }
        async function updateCountsUI() {
            /* ... snippet2's updateCountsUI ... */
            try {
                const qa = (await getAllRecords(STORES.TRAINING_DATA)).length;
                const pt = (await getAllRecords(STORES.CALCULATION_PATTERNS)).length;
                const ms = (await getAllRecords(STORES.CHAT_HISTORY)).length;
                if (qaCountBadge) qaCountBadge.textContent = qa;
                if (patternCountBadge) patternCountBadge.textContent = pt;
                if (totalQACountEl) totalQACountEl.textContent = qa;
                if (totalPatternCountEl) totalPatternCountEl.textContent = pt;
                if (totalMessageCountEl) totalMessageCountEl.textContent = Math.ceil(ms / 2); // Assuming pairs of messages
            } catch (e) {
                console.error("Failed to update counts UI", e);
            }
        }
        async function updateSystemInfoUI() {
            /* ... snippet2's updateSystemInfoUI ... */
            if (dbNameValueEl) dbNameValueEl.textContent = DB_NAME;
            if (dbVersionValueEl) dbVersionValueEl.textContent = DB_VERSION;
            try {
                const files = await getAllRecords(STORES.UPLOADED_FILES);
                if (uploadedFilesInfoDiv) {
                    const placeholder = uploadedFilesInfoDiv.querySelector('p.text-muted.small.mb-0');
                    if (files.length > 0) {
                        if (placeholder) placeholder.remove();
                        uploadedFilesInfoDiv.innerHTML = files.map(f => `<div class="mb-1 small"><i class="fas fa-file-alt me-1 text-muted"></i>${escapeHtml(f.filename)} <span class="text-muted">(${(f.size / 1024).toFixed(1)}KB, ${new Date(f.timestamp).toLocaleDateString()})</span></div>`).join('');
                    } else if (!placeholder) {
                        uploadedFilesInfoDiv.innerHTML = '<p class="text-muted small mb-0">No files imported yet.</p>';
                    }
                }
            } catch (e) {
                if (uploadedFilesInfoDiv) uploadedFilesInfoDiv.innerHTML = '<p class="text-danger small">Error loading file log.</p>';
            }
            await loadChatHistory();
        }
        async function loadChatHistory() {
            /* ... snippet2's loadChatHistory ... */
            try {
                const history = await getAllRecords(STORES.CHAT_HISTORY);
                if (!chatContainer) {
                    console.error("Chat container not found for loading history.");
                    return;
                }
                chatContainer.innerHTML = ''; // Clear before loading
                if (history.length > 0) {
                    if (welcomeMessageDiv) welcomeMessageDiv.classList.add('hidden');
                    history.sort((a, b) => a.timestamp - b.timestamp).forEach(msg => {
                        // Pass isTyping as false, assuming history doesn't store typing indicators
                        appendChatMessage(msg.type, msg.content, msg.timestamp, false);
                    });
                } else {
                    if (welcomeMessageDiv) welcomeMessageDiv.classList.remove('hidden');
                }
                await updateCountsUI();
            } catch (error) {
                console.error("Error loading chat history:", error);
                if (welcomeMessageDiv) welcomeMessageDiv.classList.remove('hidden');
                // Initial welcome message is handled in DOMContentLoaded
            }
        }

        // --- Event Handlers (from snippet2, adapted for new logic) ---
        async function handleSendMessage(event) { // Adapted from snippet2
            if (event) event.preventDefault();
            if (!messageInput || !loadingSpinner || !chatContainer) return;

            const userMessage = messageInput.value.trim();
            if (!userMessage) return;

            appendChatMessage('user', userMessage);
            addActivityLog(`User: "${userMessage.substring(0, 50)}..."`);
            messageInput.value = '';
            loadingSpinner.style.display = 'flex';
            appendChatMessage('bot', '', Date.now(), true); // Typing indicator

            let botResponse = null;
            const userMessageTimestamp = Date.now();

            try {
                // --- Combined Calculation Approach ---
                // 1. Try snippet2's dynamic calculation (code_snippet) first
                const calculationPatterns = await getAllRecords(STORES.CALCULATION_PATTERNS);
                const normalizedUserMessage = userMessage.toLowerCase();
                let dynamicCalcResult = null;

                for (const pattern of calculationPatterns) {
                    const patternTrigger = (pattern.pattern || '').toLowerCase();
                    if (pattern.code_snippet && patternTrigger && normalizedUserMessage.includes(patternTrigger)) {
                        dynamicCalcResult = await executeDynamicCalculation(pattern, userMessage); // Pass original userMessage
                        if (dynamicCalcResult !== null && dynamicCalcResult !== undefined && !(typeof dynamicCalcResult === 'string' && dynamicCalcResult.toLowerCase().includes("error"))) {
                            botResponse = `**${pattern.action || 'Custom Rule'}**:\n\`\`\`\n${String(dynamicCalcResult)}\n\`\`\`\nBased on rule: \`${pattern.pattern}\``;
                            if (pattern.formula) botResponse += `\n**Formula : ${pattern.formula}**`;
                            break; // Found a dynamic calculation
                        } else if (typeof dynamicCalcResult === 'string' && dynamicCalcResult.toLowerCase().includes("please provide numbers")) {
                            botResponse = dynamicCalcResult; // Show specific error message
                            break;
                        }
                        // If error or null, it will fall through to getResponse
                    }
                }

                // 2. If no dynamic calculation was successful, proceed with snippet1's getResponse
                //    which includes snippet1's checkFunctionPatterns (math.js, hardcoded patterns)
                if (!botResponse) {
                    botResponse = await getResponse(userMessage); // Uses snippet1's getResponse
                }

                if (!botResponse) { // Fallback if getResponse also didn't find anything
                    botResponse = "I'm sorry, I don't have a specific answer or calculation for that. Can you try rephrasing?";
                }

                await addRecord(STORES.CHAT_HISTORY, {
                    type: 'user',
                    content: userMessage,
                    timestamp: userMessageTimestamp
                });
                await addRecord(STORES.CHAT_HISTORY, {
                    type: 'bot',
                    content: String(botResponse),
                    timestamp: Date.now()
                });

                await delay(300 + Math.random() * 300); // Slightly shorter delay
                await typeBotMessage(String(botResponse));
                addActivityLog(`Bot: "${String(botResponse).substring(0, 50)}..."`);

            } catch (error) {
                const errorMsg = 'Sorry, an error occurred. Please try again.';
                await typeBotMessage(errorMsg);
                console.error('Error during send message processing:', error);
                notify('Error processing message: ' + error.message, 'danger');
                addActivityLog(`ERROR processing message: ${error.message}`);
                try { // Save error to history
                    await addRecord(STORES.CHAT_HISTORY, {
                        type: 'user',
                        content: userMessage,
                        timestamp: userMessageTimestamp
                    });
                    await addRecord(STORES.CHAT_HISTORY, {
                        type: 'bot',
                        content: errorMsg,
                        timestamp: Date.now()
                    });
                } catch (dbError) {
                    console.error("Error saving error message to DB", dbError);
                }
            } finally {
                if (loadingSpinner) loadingSpinner.style.display = 'none';
                const typingEl = chatContainer ? chatContainer.querySelector('.is-typing') : null;
                if (typingEl) typingEl.remove();
                await updateCountsUI();
            }
        }

        // Save Training Data (adapting snippet1's saveTrainingData for snippet2's UI)
        async function saveNewTrainingData() { // Renamed to avoid conflict if snippet1's was global
            const questionElement = document.getElementById('trainQuestionInput'); // Assuming IDs from a typical form
            const answerElement = document.getElementById('trainAnswerInput');

            if (!questionElement || !answerElement) {
                notify('Training input fields not found.', 'error');
                return;
            }
            const question = questionElement.value.trim();
            const answer = answerElement.value.trim();

            if (!question || !answer) {
                notify('Please provide both question and answer.', 'error');
                return;
            }
            try {
                await addTrainingData(question, answer); // Uses snippet1's function
                questionElement.value = '';
                answerElement.value = '';
                notify('Training data saved successfully!', 'success');
                addActivityLog(`Added new Q&A: ${question.substring(0,30)}...`);
                await renderTrainingList('qa', 1); // Refresh list
            } catch (error) {
                console.error('Error saving training data:', error);
                notify('Failed to save training data: ' + error.message, 'error');
            }
        }

        // Save Calculation Pattern (adapting snippet1's for snippet2's UI and code_snippet)
        async function saveNewCalculationPattern() { // Renamed
            const patternElement = document.getElementById('calcPatternInput');
            const actionElement = document.getElementById('calcActionInput');
            const formulaElement = document.getElementById('calcFormulaInput');
            const codeSnippetElement = document.getElementById('calcCodeSnippetInput'); // Assuming this field exists

            if (!patternElement || !actionElement || !formulaElement || !codeSnippetElement) {
                notify('Calculation pattern input fields not found.', 'error');
                return;
            }
            const pattern = patternElement.value.trim();
            const action = actionElement.value.trim();
            const formula = formulaElement.value.trim();
            const codeSnippet = codeSnippetElement.value.trim();

            if (!pattern || !action) { // Formula and code_snippet can be optional
                notify('Pattern and Action are required for calculation patterns.', 'error');
                return;
            }
            try {
                // Using addCalcPatternData (from snippet2, which uses addRecord)
                // to ensure code_snippet is saved correctly.
                await addCalcPatternData(pattern, action, formula, codeSnippet);
                patternElement.value = '';
                actionElement.value = '';
                formulaElement.value = '';
                codeSnippetElement.value = '';
                notify('Calculation pattern saved successfully!', 'success');
                addActivityLog(`Added new Calc Pattern: ${pattern.substring(0,30)}...`);
                await renderTrainingList('pattern', 1); // Refresh list
            } catch (error) {
                console.error('Error saving calculation pattern:', error);
                notify('Failed to save calculation pattern: ' + error.message, 'error');
            }
        }

        // Event listener for training list edit/delete (from snippet2, largely unchanged)
        // Ensure it handles both 'qa' and 'pattern' types correctly for prompts
        document.getElementById('trainingDataTabContent')?.addEventListener('click', async (e) => {
            const target = e.target.closest('button.edit-btn, button.delete-btn');
            if (!target) return;
            const id = parseInt(target.dataset.id);
            const type = target.dataset.type; // 'qa' or 'pattern'
            const storeName = type === 'qa' ? STORES.TRAINING_DATA : STORES.CALCULATION_PATTERNS;
            try {
                if (target.classList.contains('edit-btn')) {
                    const item = await getRecordById(storeName, id);
                    if (!item) return notify('Item not found to edit.', 'warning');

                    if (type === 'qa') {
                        const newQ = prompt('Edit Question:', item.question);
                        if (newQ === null) return;
                        const newA = prompt('Edit Answer:', item.answer);
                        if (newA === null) return;
                        await updateRecord(storeName, {
                            ...item,
                            question: newQ.trim().toLowerCase(),
                            answer: newA.trim(),
                            timestamp: Date.now()
                        });
                    } else { // 'pattern'
                        const newP = prompt('Edit Pattern:', item.pattern);
                        if (newP === null) return;
                        const newAct = prompt('Edit Action:', item.action);
                        if (newAct === null) return;
                        const newF = prompt('Edit Formula:', item.formula || '');
                        // if (newF === null) return; // Formula can be empty
                        const newCS = prompt('Edit Code Snippet:', item.code_snippet || '');
                        // if (newCS === null) return; // Code snippet can be empty
                        await updateRecord(storeName, {
                            ...item,
                            pattern: newP.trim().toLowerCase(),
                            action: newAct.trim(),
                            formula: newF.trim(),
                            code_snippet: newCS.trim(),
                            timestamp: Date.now()
                        });
                    }
                    notify(`${type.toUpperCase()} item updated.`, 'success');
                    addActivityLog(`Edited ${type} ID: ${id}`);
                } else if (target.classList.contains('delete-btn')) {
                    if (confirm(`Delete this ${type.toUpperCase()} item?`)) {
                        await deleteRecord(storeName, id);
                        notify(`${type.toUpperCase()} item deleted.`, 'success');
                        addActivityLog(`Deleted ${type} ID: ${id}`);
                    } else return;
                }
                // Refresh the correct list
                const pagDiv = type === 'qa' ? qaPaginationDiv : patternPaginationDiv;
                const currentPageButton = pagDiv ? pagDiv.querySelector('.btn-primary.active') : null;
                const currentPage = currentPageButton ? parseInt(currentPageButton.textContent) || 1 : 1;
                await renderTrainingList(type, currentPage);
            } catch (err) {
                notify(`Error with ${type} item: ` + err.message, 'danger');
            }
        });


        // Other event handlers from snippet2 (largely unchanged, but using merged core functions)
        async function handleImportFileFromInput() {
            /* Uses importJSONFromFile (aliased importJSON) */
            if (!importFileEl || !importProgressCard || !progressBar || !progressText) return;
            const file = importFileEl.files[0];
            if (!file) return notify('No file selected.', 'warning');
            if (!file.name.endsWith('.json') && file.type !== 'application/json') return notify('Invalid file. Must be JSON.', 'danger');

            importProgressCard.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressText.textContent = 'Reading file...';
            try {
                const content = await file.text();
                const jsonData = JSON.parse(content);
                const count = await importJSONFromFile(jsonData); // Uses merged importJSON
                await addRecord(STORES.UPLOADED_FILES, {
                    filename: file.name,
                    size: file.size,
                    type: file.type,
                    timestamp: Date.now()
                });
                notify(`Imported ${count} items from ${file.name}.`, 'success');
                addActivityLog(`Imported file: ${file.name} (${count} items)`);
                await Promise.all([renderTrainingList('qa', 1), renderTrainingList('pattern', 1), updateSystemInfoUI()]);
            } catch (e) {
                notify('Import error: ' + e.message, 'danger');
                addActivityLog(`ERROR importing file: ${e.message}`);
                progressText.textContent = 'Import failed.';
            } finally {
                setTimeout(() => {
                    importProgressCard.style.display = 'none';
                }, 2000);
                if (importFileEl) importFileEl.value = ''; // Clear file input
            }
        }
        async function handleImportJsonFromTextArea() {
            /* Uses importJSONFromFile */
            if (!jsonImportTextArea || !importProgressCard || !progressBar || !progressText) return;
            const jsonString = jsonImportTextArea.value.trim();
            if (!jsonString) return notify('Text area is empty. Paste JSON data to import.', 'warning');

            importProgressCard.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressText.textContent = 'Parsing JSON...';
            try {
                const jsonData = JSON.parse(jsonString);
                const count = await importJSONFromFile(jsonData); // Uses merged importJSON
                notify(`Imported ${count} items from text area.`, 'success');
                addActivityLog(`Imported from text area: ${count} items`);
                await Promise.all([renderTrainingList('qa', 1), renderTrainingList('pattern', 1), updateSystemInfoUI()]);
                jsonImportTextArea.value = '';
            } catch (e) {
                notify('Import error from text area: ' + e.message, 'danger');
                addActivityLog(`ERROR importing from text area: ${e.message}`);
                progressText.textContent = 'Import failed.';
            } finally {
                setTimeout(() => {
                    importProgressCard.style.display = 'none';
                    progressText.textContent = 'Import finished.';
                }, 2000);
            }
        }

        function handleDownloadJsonTemplate() {
            /* ... snippet2's handleDownloadJsonTemplate ... */
            const template = {
                "qa_pairs": [{
                    "id": 1,
                    "question": "Sample Q1?",
                    "answer": "Sample A1",
                    "timestamp": Date.now()
                }],
                "calculation_patterns": [{
                    "id": 1,
                    "pattern": "double {num}",
                    "action": "calculate_double_custom",
                    "formula": "num * 2",
                    "code_snippet": "function(num){ return num * 2; }",
                    "timestamp": Date.now()
                }]
            };
            const blob = new Blob([JSON.stringify(template, null, 2)], {
                type: 'application/json'
            });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `chatbot_template_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            notify('JSON template download initiated.', 'info');
            addActivityLog('Downloaded JSON template.');
        }
        async function handleExportData() {
            /* Uses exportToJSON */
            try {
                const jsonStr = await exportToJSON(); // Uses merged exportToJSON
                const blob = new Blob([jsonStr], {
                    type: 'application/json'
                });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `chatbot_data_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
                notify('Data exported successfully!', 'success');
                addActivityLog('Exported all data.');
            } catch (e) {
                notify('Export error: ' + e.message, 'danger');
            }
        }
        async function handleClearChatHistory() {
            /* ... snippet2's handleClearChatHistory ... */
            if (1 == 1) {
                try {
                    await clearStore(STORES.CHAT_HISTORY);
                    if (chatContainer) chatContainer.innerHTML = '';
                    if (welcomeMessageDiv) welcomeMessageDiv.classList.remove('hidden');
                    notify('Chat history cleared.', 'success');
                    addActivityLog('Chat history cleared.');
                    await updateCountsUI();
                } catch (e) {
                    notify('Error clearing history: ' + e.message, 'danger');
                }
            }
        }
        async function handleResetDatabase() {
            /* ... snippet2's handleResetDatabase ... */
            if (1 == 1) {
                try {
                    await Promise.all(Object.values(STORES).map(sName => clearStore(sName)));
                    notify('ENTIRE DATABASE RESET!', 'danger', 10000);
                    addActivityLog('ENTIRE DATABASE RESET.');
                    if (chatContainer) chatContainer.innerHTML = '';
                    if (welcomeMessageDiv) welcomeMessageDiv.classList.remove('hidden');
                    // Reset pending suggestions as well
                    pendingSuggestion = null;
                    pendingAnswer = null;
                    await Promise.all([renderTrainingList('qa', 1), renderTrainingList('pattern', 1), updateSystemInfoUI()]);
                } catch (e) {
                    notify('Database reset failed: ' + e.message, 'danger');
                }
            } else {
                notify('Reset cancelled. Confirmation phrase was incorrect.', 'warning');
            }
        }
        async function handleClearUploadedFilesLog() {
            /* ... snippet2's handleClearUploadedFilesLog ... */
            if (1 == 1) {
                try {
                    await clearStore(STORES.UPLOADED_FILES);
                    notify('Uploaded files log cleared.', 'success');
                    addActivityLog('Uploaded files log cleared.');
                    await updateSystemInfoUI();
                } catch (e) {
                    notify('Error clearing files log: ' + e.message, 'danger');
                }
            }
        }

        async function fetchAndInstallDefaultData(url, typeName) {
            /* Uses importJSONFromFile */
            if (!importProgressCard || !progressBar || !progressText) return;
            importProgressCard.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';
            progressText.textContent = `Fetching ${typeName}...`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Fetch failed: ${response.status} for ${url}`);
                const jsonData = await response.json();
                progressText.textContent = `Importing ${typeName}...`;
                const count = await importJSONFromFile(jsonData); // Uses merged importJSON
                notify(`Installed ${count} ${typeName} items.`, 'success');
                addActivityLog(`Installed default: ${typeName} (${count} items)`);
                await Promise.all([renderTrainingList('qa', 1), renderTrainingList('pattern', 1), updateSystemInfoUI()]);
            } catch (e) {
                notify(`Error installing ${typeName}: ${e.message}`, 'danger');
                addActivityLog(`ERROR installing default ${typeName}: ${e.message}`);
                progressText.textContent = `${typeName} installation failed.`;
            } finally {
                setTimeout(() => {
                    importProgressCard.style.display = 'none';
                }, 2000);
            }
        }

        function generatePrompt() {
            /* ... snippet2's generatePrompt ... */
            if (!topicInput || !searchEngineToggle) return;
            const topicVal = topicInput.value.trim();
            if (!topicVal) return notify("Please enter a topic.", 'warning');
            const promptStr = `Generate training data for an AI chatbot on the topic "${topicVal}". Return a single JSON object in exactly this structure:

{
  "qa_pairs": [
    { "question": "...", "answer": "..." }
  ],
  "calculation_patterns": [
    { "pattern": "...", "action": "...", "formula": "...", "code_snippet": "..." }
  ]
}

Rules:
 Use "qa_pairs" for fact-based content. Produce 50 pairs when only Q&A is needed.  
 Use "calculation_patterns" when the topic needs calculative actions; provide suitable patterns and at least 30 QA pairs alongside them.  
 Keep any unused section as an empty array.  
 Try to use single word or less word combinaton in "question" and "pattern"
 Output only valid JSON, no extra text.

Example format:
{
  "qa_pairs": [
    { "question": "javascript", "answer": "JavaScript is a programming language." }
  ],
  "calculation_patterns": [
    {
      "pattern": "double",
      "action": "calculate_double",
      "formula": "result = 2 * number",
      "code_snippet": "function double(number) { return 2 * number; }"
    }
  ]
}`;
            const usePerplexity = searchEngineToggle.checked;
            const searchUrl = usePerplexity ? `https://www.perplexity.ai/search?q=${encodeURIComponent(promptStr)}` : `https://chat.openai.com/?q=${encodeURIComponent(promptStr)}`; // Use chat.openai.com as fallback
            window.open(searchUrl, '_blank', 'noopener,noreferrer,width=1000,height=700');
            addActivityLog(`Generated training prompt for topic: ${topicVal}`);
        }

        // --- DOMContentLoaded Initializer (from snippet2, with migration call) ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Assign UI elements (from snippet2)
            chatContainer = document.getElementById('chatContainer');
            messageInput = document.getElementById('messageInput');
            chatForm = document.getElementById('chatForm');
            loadingSpinner = document.getElementById('loadingSpinner');
            welcomeMessageDiv = document.getElementById('welcomeMessage');
            qaListDiv = document.getElementById('qaList');
            patternListDiv = document.getElementById('patternList');
            qaPaginationDiv = document.getElementById('qaPagination');
            patternPaginationDiv = document.getElementById('patternPagination');
            totalQACountEl = document.getElementById('totalQACount');
            totalPatternCountEl = document.getElementById('totalPatternCount');
            totalMessageCountEl = document.getElementById('totalMessageCount');
            qaCountBadge = document.getElementById('qaCount');
            patternCountBadge = document.getElementById('patternCount');
            dbNameValueEl = document.getElementById('dbNameValue');
            dbVersionValueEl = document.getElementById('dbVersionValue');
            dbStatusEl = document.getElementById('dbStatus');
            recentActivityDiv = document.getElementById('recentActivity');
            uploadedFilesInfoDiv = document.getElementById('uploadedFilesInfo');
            importProgressCard = document.getElementById('importProgressCard');
            progressBar = document.getElementById('progressBar');
            progressText = document.getElementById('progressText');
            importFileEl = document.getElementById('importFile');
            jsonImportTextArea = document.getElementById('jsonImportTextArea');
            topicInput = document.getElementById('topicInput');
            searchEngineToggle = document.getElementById('searchEngineToggle');

            try {
                if (dbStatusEl) {
                    dbStatusEl.textContent = 'Connecting...';
                    dbStatusEl.className = 'badge bg-warning';
                }
                await initDB();
                if (dbStatusEl) {
                    dbStatusEl.textContent = 'Connected';
                    dbStatusEl.className = 'badge bg-success';
                }
                addActivityLog('Application initialized & DB connected.');

                await migrateFromLocalStorage(); // Call migration

                await Promise.all([
                    renderTrainingList('qa', 1),
                    renderTrainingList('pattern', 1),
                    updateSystemInfoUI() // This also calls loadChatHistory
                ]);

                // Attach event listeners (from snippet2)
                if (chatForm) chatForm.addEventListener('submit', handleSendMessage);
                if (messageInput) messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleSendMessage();
                    }
                });

                // Event listeners for training forms
                document.getElementById('saveTrainDataBtn')?.addEventListener('click', saveNewTrainingData);
                document.getElementById('saveCalcPatternBtn')?.addEventListener('click', saveNewCalculationPattern);


                if (importFileEl) importFileEl.addEventListener('change', handleImportFileFromInput);
                document.getElementById('exportAllData')?.addEventListener('click', handleExportData);
                document.getElementById('installConversationData')?.addEventListener('click', () => fetchAndInstallDefaultData(DEFAULT_CONVERSATION_URL, 'Conversation Data'));
                document.getElementById('installDictionaryData')?.addEventListener('click', () => fetchAndInstallDefaultData(DEFAULT_DICTIONARY_URL, 'Dictionary Data'));
                document.getElementById('clearChatHistory')?.addEventListener('click', handleClearChatHistory);
                document.getElementById('resetEntireDatabase')?.addEventListener('click', handleResetDatabase);
                document.getElementById('clearUploadedFilesRecords')?.addEventListener('click', handleClearUploadedFilesLog);
                document.getElementById('generatePromptBtn')?.addEventListener('click', generatePrompt);
                document.getElementById('importJsonFromTextAreaBtn')?.addEventListener('click', handleImportJsonFromTextArea);
                document.getElementById('downloadJsonTemplateBtn')?.addEventListener('click', handleDownloadJsonTemplate);


                // Tab switching (if you have Bootstrap tabs)
                document.querySelectorAll('.nav-link[data-bs-toggle="tab"]').forEach(tab => {
                    tab.addEventListener('shown.bs.tab', async event => {
                        addActivityLog(`Switched to tab: ${event.target.textContent.trim()}`);
                        if (event.target.hash === '#trainingDataTab') { // Assuming this is the ID of the training data tab content
                            await renderTrainingList('qa', 1);
                            await renderTrainingList('pattern', 1);
                        } else if (event.target.hash === '#systemInfoTab') {
                            await updateSystemInfoUI();
                        }
                    });
                });


                // Initial welcome message if no history
                const history = await getAllRecords(STORES.CHAT_HISTORY);
                if (history.length === 0 && welcomeMessageDiv && chatContainer && chatContainer.children.length === 0) {
                    const clonedWelcomeMessage = welcomeMessageDiv.cloneNode(true);
                    clonedWelcomeMessage.removeAttribute('id');
                    clonedWelcomeMessage.style.display = 'block';
                    chatContainer.appendChild(clonedWelcomeMessage);
                }


                console.log("Chatbot UI initialized with merged features.");
                notify("Welcome to your AI Chatbot Interface!", "primary");

            } catch (error) {
                console.error('FATAL Initialization Error:', error);
                if (dbStatusEl) {
                    dbStatusEl.textContent = 'ERROR';
                    dbStatusEl.className = 'badge bg-danger';
                }
                notify('CRITICAL ERROR: App failed to initialize. ' + error.message, 'danger', 10000);
                addActivityLog('FATAL ERROR on init: ' + error.message);
            }
        });
    </script>
</body>

</html>
